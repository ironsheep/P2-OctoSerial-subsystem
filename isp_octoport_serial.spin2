'' =================================================================================================
''
''   File....... isp_octoport_serial.spin2
''   Purpose.... Create multiple serial ports using a single cog
''               Buffered serial communications using smart pins
''               -- mostly matches jm_FullDuplexSerial.spin2
''               -- does NOT support half-duplex communications using shared RX/TX pin
''   Authors.... Stephen M Moraco
''               -- based on work by Bob Sweeney
''               -- based on work by Jon McPhalen
''               -- based on work by Chip Gracey
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started....
''   Updated.... 18 Nov 2022
''
'' =================================================================================================

{{
   Run several (8 default) serial ports at a time. Run 'AddPort' prior to 'Start' to configure smart pins.
   AddPort return   value is the portID. Code is based on jm_fullduplexserial.spin2.
   More than 8 ports can be run by adjusting the MAX_PORT value and pasm array variable sizes to accomodate
   more ports. Each port can have either a tx and rx pin associated with it.

   Initial version does not contain all methods in jm_fullduplexserial.spin2 in order to simplify for
   intial testing purposes

   Note: Buffer size no longer has to be power-of-2 integer.

   The smart pin uarts use a 16-bit value for baud timing which can limit low baud rates for
   some system frequencies -- beware of these limits when connecting to older devices.

    Baud     20MHz    40MHz    80MHz    100MHz    200MHz    300MHz
   ------    -----    -----    -----    ------    ------    ------
      300       No       No       No        No        No        No
      600      Yes       No       No        No        No        No
     1200      Yes      Yes       No        No        No        No
     2400      Yes      Yes      Yes       Yes        No        No
     4800      Yes      Yes      Yes       Yes       Yes       Yes

}}

CON { PUBLIC Interface Enums }

' "or" the following flag-constants together to build a serial mode value (or use MODE_NONE if no flags needed)
'  (e.g.,  MY_PORT_MODE = MODE_FLAG_INV_RX | MODE_OPEN_DRN_SRC_TX)

' -- mode.... %0xx1 = invert rx
  MODE_FLAG_INV_RX = %0001
'             %0x1x = invert tx
  MODE_FLAG_INV_TX = %0010
'             %01xx = open-drain/open-source tx
  MODE_OPEN_DRN_SRC_TX = %0100

  MODE_NONE = 0 ' no mode values needed

  PIN_NOT_NEEDED = -1

CON { pst formatting }

  HOME     =  1
  CRSR_XY  =  2
  CRSR_LF  =  3
  CRSR_RT  =  4
  CRSR_UP  =  5
  CRSR_DN  =  6
  BELL     =  7
  BKSP     =  8
  TAB      =  9
  LF       = 10
  CLR_EOL  = 11
  CLR_DN   = 12
  CR       = 13
  CRSR_X   = 14
  CRSR_Y   = 15
  CLS      = 16

CON
  ' serial specific constants
  BUF_SIZE       = 32                                           ' size of rx and tx buffers
  MAX_PORT       = 8                                            ' set to number of ports to be used (0-8)
  MAX_LONG_TABLES = 8                                            ' set to number of ports to be used (0-8)


VAR
  long  cog                                                     ' cog flag/id

  ' /----------------------------------------------
  ' . structure copied to PASM driver before start
  long  activPortCount                                               ' total number of open ports (0-7)
  long  pinRx[MAX_PORT]                                         ' rx pin array - cog rxbuff
  long  pinTx[MAX_PORT]                                         ' tx pin array - cog txbuff
  long  pRxBuf[MAX_PORT]                                       ' ptr array to port tx buffer hub address - cog p_rxbuf
  long  pTxBuf[MAX_PORT]                                       ' ptr array to port rx buffer hub address - cog p_txbuf
  long  p_rxHd[MAX_PORT]                                        ' cog ptr to rxHeadIdx[] hub address start
  long  p_txHd[MAX_PORT]                                        ' cog ptr to txHeadIdx[] hub address start
  long  p_rxTl[MAX_PORT]                                        ' cog ptr to txTailIdx[] hub address start
  long  p_txTl[MAX_PORT]                                        ' cog ptr to txTailIdx[] hub address start
  ' \----------------------------------------------

  long  rxHeadIdx[MAX_PORT]                                     ' rx/tx head/tail array of indexes
  long  rxTailIdx[MAX_PORT]                                     '
  long  txHeadIdx[MAX_PORT]                                     '
  long  txTailIdx[MAX_PORT]                                     '
  long  txDelay[MAX_PORT]                                       ' port baud rate

  byte  rxbuf[BUF_SIZE * MAX_PORT]                              ' buffers - set MAX_PORT to actual open ports
  byte  txbuf[BUF_SIZE * MAX_PORT]

  byte  pbuf[80]                                                ' padded strings


PUB null()
'' This is not a top-level object

'----------------------------------------------------------------------------------------------------

PUB addport(rxp, txp, mode, baud) : portHandle | baudcfg, spmode, tdelay, portIdx, validPin
'' call method before start(). miniumum 1 port required
'' load data arrays and setup smartpins
'' does not check for port duplication
'' run addport at least once before calling start method
'' returns {portHandle} to use when accessing this port (value: (0 to MAX_PORT-1) or -1 if error)
'' -- rxp... receive pin (-1 if not used)
'' -- txp... transmit pin (-1 if not used)
'' -- mode.... %0xx1 = invert rx (MODE_FLAG_INV_RX)
''             %0x1x = invert tx (MODE_FLAG_INV_TX)
''             %01xx = open-drain/open-source tx (MODE_OPEN_DRN_SRC_TX)

  if (rxp == txp)                                            ' pins must be unique
    portHandle := -1
    debug("* Invalid Rx pin (", sdec(rxp), ") can not be same pin as Tx (", sdec(txp), ")")
    abort

  validPin := -1 #> rxp <# 63
  if rxp <> validPin
    debug("* Invalid Rx pin (", sdec(rxp), ")")
    portHandle := -1
    abort

  validPin := -1 #> txp <# 63
  if txp <> validPin
    debug("* Invalid Tx pin (", sdec(txp), ")")
    portHandle := -1
    abort

  ' check if pin used by any other ports
  if activPortCount > 0
    repeat portIdx from 0 to activPortCount - 1
      if pinRx[activPortCount] == rxp or pinTx[activPortCount] == rxp
         debug("* Dupe: Rx pin (", sdec(rxp), ") already in use")
         portHandle := -1
         quit
      if pinRx[activPortCount] == txp or pinTx[activPortCount] == txp
         debug("* Dupe: Tx pin (", sdec(txp), ") already in use")
         portHandle := -1
         quit

  if activPortCount > (MAX_PORT-1)                                    ' port in range
    portHandle := -1                                                 ' error, initializing too many ports
    debug("* ERROR: all ports in use. More than 8 ports not supported!")
    abort
  else
    portHandle := activPortCount                                          ' return port number (0-7), -1 if error

  txDelay[activPortCount] := clkfreq / baud * 11                      ' tix to transmit one byte

  baudcfg := muldiv64(clkfreq, $1_0000, baud) & $FFFFFC00        ' set bit timing
  baudcfg |= (8-1)                                               ' set bits (8)

  pinRx[activPortCount] := rxp                                     ' save rx pin

  if pinRx[activPortCount] >= 0                                      ' configure rx pin if used
    spmode := P_ASYNC_RX
    if (mode.[0])
      spmode |= P_INVERT_IN
    pinstart(pinRx[activPortCount], spmode, baudcfg, 0)

  pinTx[activPortCount] := txp                                     ' save tx pin

  if pinTx[activPortCount] >= 0                                      ' configure tx pin if used
    spmode := P_ASYNC_TX | P_OE
    case mode.[2..1]
      %01 : spmode |= P_INVERT_OUTPUT
      %10 : spmode |= P_HIGH_FLOAT                               ' requires external pull-up
      %11 : spmode |= P_INVERT_OUTPUT | P_LOW_FLOAT              ' requires external pull-down
    pinstart(pinTx[activPortCount], spmode, baudcfg, 0)

  pRxBuf[activPortCount] := @BYTE[@rxbuf][activPortCount * BUF_SIZE]               ' ptr to hub buffer address
  pTxBuf[activPortCount] := @BYTE[@txbuf][activPortCount * BUF_SIZE]

  p_rxHd[activPortCount] := @rxHeadIdx[activPortCount]                        ' ptr to hub addresses
  p_txHd[activPortCount] := @txHeadIdx[activPortCount]
  p_rxTl[activPortCount] := @rxTailIdx[activPortCount]
  p_txTl[activPortCount] := @txTailIdx[activPortCount]

  debug("---------------")
  debug(uhex(activPortCount))
  debug(uhex(pinRx[activPortCount]))
  debug(uhex(pinTx[activPortCount]))
  debug(uhex(pRxBuf[activPortCount]))
  debug(uhex(pTxBuf[activPortCount]))
  debug(uhex(p_rxHd[activPortCount]))
  debug(uhex(p_txHd[activPortCount]))
  debug(uhex(p_rxTl[activPortCount]))
  debug(uhex(p_txTl[activPortCount]))

  activPortCount++



PUB start() : portHandle
'' Start new cog

  stop()
  cog := coginit(COGEXEC_NEW, @uart_mgr, @activPortCount) + 1         ' start uart manager cog
  return cog


PUB stop()
'' Stop serial driver
'' -- frees a cog if driver was running

  if (cog)                                                      ' cog active?
    cogstop(cog-1)                                              '  yes, shut it down
    cog := 0                                                    '  and mark stopped


PUB rx(portval) : b
'' Pulls byte from receive buffer if available
'' -- will wait if buffer is empty
  debug(sdec(portval))

  repeat while rxTailIdx[portval] == rxHeadIdx[portval]               ' hold while buffer empty

  b := rxbuf[(portval * BUF_SIZE) + rxTailIdx[portval]]            ' get a byte
  debug(sdec(b))
  debug(sdec(BUF_SIZE))
  debug(sdec(rxTailIdx[portval]))

  if ++rxTailIdx[portval] == BUF_SIZE                              ' update tail pointer
    rxTailIdx[portval] := 0


PUB rxcheck(portval) : b
'' Pulls byte from receive buffer if available
'' -- returns -1 if buffer is empty

  if rxTailIdx[portval] <> rxHeadIdx[portval]                          ' something in buffer?
    b := rxbuf[(portval * BUF_SIZE) + rxTailIdx[portval]]           ' get a byte
    if ++rxTailIdx[portval] == BUF_SIZE                             ' update tail pointer
      rxTailIdx[portval] := 0
  else
    b := -1                                                      ' mark no byte available


PUB rxtime(portval, ms) : b | mstix, t

'' Wait ms milliseconds for a byte to be received
'' -- returns -1 if no byte received, $00..$FF if byte

  mstix := clkfreq / 1000

  t := getct()
  repeat until ((b := rxcheck(portval)) >= 0) || (((getct()-t) / mstix) >= ms)


PUB rxtix(portval, tix) : b | t
'' Waits tix clock ticks for a byte to be received
'' -- returns -1 if no byte received

  t := getct()
  repeat until ((b := rxcheck(portval)) >= 0) || ((getct()-t) >= tix)


PUB available(portval) : count
'' Returns # of bytes waiting in rx buffer

  if (rxTailIdx[portval] <> rxHeadIdx[portval])                        ' if byte(s) available
    count := rxHeadIdx[portval] - rxTailIdx[portval]                   ' get count
    if (count < 0)
      count += BUF_SIZE                                         ' fix for wrap around


PUB rxflush(portval)
'' Flush receive buffer

  repeat while (rxcheck(portval) >= 0)


PUB tx(portval, b) | n
'' Move byte into transmit buffer if room is available
'' -- will wait if buffer is full
  debug(sdec(portval), sdec(b))
  repeat
    ' . possible situations:
    ' .   | .  head  tail |
    ' .   | . tail   head  |
    n := txHeadIdx[portval] - txTailIdx[portval]                       ' bytes in buffer FIXME: BROKEN
    debug(n)

    if (n < 0)                                                   ' fix for index wrap-around
      n += BUF_SIZE
    if (n < BUF_SIZE-1)
      ' OVERFLOW: no room for xmit byte
      quit

  txbuf[(portval * BUF_SIZE) + txHeadIdx[portval]] := b             ' move to buffer offset location
  if (++txHeadIdx[portval] == BUF_SIZE)                             ' update head pointer
    txHeadIdx[portval] := 0


PUB txn(portval, b, n)
'' Emit byte n times

  repeat n
    tx(portval, b)


PUB str(portval, p_str)
'' Emit z-string at p_str

  repeat (strsize(p_str))
    tx(portval, byte[p_str++])
    debug(sdec(p_str))
    debug(sdec(byte[p_str]))


PUB substr(portval, p_str, len) | b
'' Emit len characters of string at p_str
'' -- aborts if end of string detected

  repeat len
    b := byte[p_str++]
    if (b > 0)
      tx(portval, b)
    else
      quit


PUB txflush(portval)
'' Wait for transmit buffer to empty
'' -- will delay one byte period after buffer is empty

  repeat until (txTailIdx[portval] == txHeadIdx[portval])             ' let buffer empty
  waitct(getct() + txDelay[portval])                            ' delay for last byte


DAT { smart pin uart/buffer manager }
'---+-----------+---------+---------------------+----+-----------+--------------+
                org
uart_mgr
                ' read hub arrays into cog
                rdlong    portnum, ptra++            ' get # of open ports
                setq      #(MAX_PORT*MAX_LONG_TABLES) ' load number of longs to copy
                rdlong    rxpin, ptra                ' block copy hub variables to cog
                sub       portnum, #1                ' subtract 1 to get actual port number max value

uart_main                                            ' loop through each port, get rx, tx pins
                mov       portctr, #0                ' initialize portctr = 0
                '-------------------------------
.loop                                                ' get offsets for array values
                alts      portctr, #rxpin            ' add portctr offset to rxpin - rxpin[portctr]
                mov       rxd, 0-0                     ' copy rxpin to rxd

                alts      portctr, #txpin            ' add portctr offset to txpin - txpin[portctr]
                mov       txd, 0-0                     ' copy txpin to txd
                                                     ' rxpin available, jump to rx_serial or tx_serial
                testb     rxd,  #31             wc      ' rx pin in use? -test for -1 when no pin saved
    if_nc       call      #rx_serial

                testb     txd, #31              wc   ' tx in use? -test for -1
    if_nc       call      #tx_serial
                                                     ' increment counter to next port. if portctr =
                                                     ' open ports, reset portctr to 0 and loop
                incmod    portctr, portnum      wc   ' check if portctr = open ports
    if_nc       jmp       #.loop                                ' repeat loop for each open port

                jmp       #uart_main

                '-------------------------------

rx_serial       testp     rxd                   wc   ' anything waiting on smartpin?
    if_nc       ret
                rdpin     t3, rxd                    ' read new byte from smartpin
                shr       t3, #24                    ' align lsb

                alts      portctr, #p_rxbuf          ' get @p_rxbuf[portctr] from hub
                mov       t1, 0-0                      ' t1 := @p_rxbuf[portctr]

                alts      portctr, #p_rxhead         ' get rxHeadIdx[portctr] value from hub
                mov       offset, 0-0                  ' offset = rxHeadIdx[portctr]
                rdlong    t2, offset                 ' read rxHeadIdx[portctr] from hub

                add       t1, t2
                wrbyte    t3, t1                     ' rxbuf[rxHeadIdx] := t3
                incmod    t2, #(BUF_SIZE-1)          ' update rxHeadIdx index
    _ret_       wrlong    t2, offset                 ' write rxHeadIdx index back to hub

                '-------------------------------

tx_serial
                rdpin     t1, txd               wc   ' check busy flag
    if_c        ret                                  '  abort if busy

                alts      portctr, #p_txhead         ' get txHeadIdx value from hub
                mov       offset, 0-0                  ' offset = address of txHeadIdx[portctr]
                rdlong    t1, offset                 ' t1 = txHeadIdx[portctr] in hub memory

                alts      portctr, #p_txtail         ' get txTailIdx value from hub
                mov       offset1, 0-0                 ' offset1 = address of txTailIdx[portctr]
                rdlong    t2, offset1                ' t2 = txTailIdx[portctr] in hub memory

                cmp       t1, t2                wz   ' byte(s) to tx?
    if_e        ret

                alts      portctr, #p_txbuf                     ' get txbuf[portctr] in hub memory
                mov       t1, 0-0                                 ' t1 := p_txbuf[portctr]
                add       t1, t2                                ' add tail index
                rdbyte    t3, t1                                ' t3 := p_txbuf[txTailIdx]
                wypin     t3, txd                               ' load into uart

                incmod    t2, #(BUF_SIZE-1)                     ' update tail index
    _ret_       wrlong    t2, offset1                           ' write tail index back to hub

                '-------------------------------

portnum         long      1                          ' total # ports
rxpin           long      0[MAX_PORT]                ' rx pin array
txpin           long      0[MAX_PORT]                ' tx pin array
p_rxbuf         long      0[MAX_PORT]                ' ptr to pRxBuf
p_txbuf         long      0[MAX_PORT]                ' ptr to pTxBuf
p_rxhead        long      0[MAX_PORT]                ' ptr to rxHeadIdx
p_txhead        long      0[MAX_PORT]                ' ptr to txHeadIdx
p_rxtail        long      0[MAX_PORT]                ' prt to rxTailIdx
p_txtail        long      0[MAX_PORT]                ' prt to txTailIdx

portctr         res       1                          ' loop counter
rxd             res       1                          ' rx pin
txd             res       1                          ' tx pin
offset          res       1
offset1         res       1
t1              res       1                          ' work vars
t2              res       1
t3              res       1

'                fit       472                       ' $1D8 P1
                fit     496                          ' $1f0 P2


CON { license }

{{

  Terms of Use: MIT License

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

}}
